# СЛОВАРЬ GIT
Инициализыция репозитория/
 Создать на компьютере папку Git/
 В папке создать несколько файлов. Например, index.txt/
 В файл внести изменения./
Открыть git bash
## Залогиниться - В git Bash набрать команды) 
    ` git config --global user.name "" `
    ` git config --global user.email "" `
## Посмотреть в какой папке мы находимся 
    ` pwd `
## Указать путь в папку Git 
    ` cd ‘путь к папке’ `
##  Создать из текущей папки GIT локальный репозиторий 
    ` git init `
## Добавить файлы из репозитория в индекс 
    ` git add . `
## Сохранить текущую версию (добавить коммит) 
    ` git commit -m "Первый коммит" `
## В GitHub создать репозиторий с именем GitName
## В Git Bash набрать команду (подключить к локальному репозиторию удаленный) 
    ` git remote add origin https://github.com/ВашЛогинНаГитхаб/GitName.git `
## Создать основную ветку
    ` git branch -M main `
## Перенести локальный репозиторий
    ` git push -u origin main `
Для того, чтобы посмотреть в какой мы папке набираем команду в GitBash:
`pwd`
Для того, чтобы посмотреть какой удаленный репозиторий подключен , набираем команду в GitBash или терминале VS Code
`git remote -v`
Если что-то идет не так набираем 
`git status`
Если что-то высвечивается красным, значит не добавили в индекс. Смотри пункт 9. Если что-то высвечивается зеленым, значит изменения добавлены в индекс, но не закомичены. Смотри пункт 10./
 Когда возникла ошибка, проанализируй все свои действия, проверь в какой ты папке, есть ли связь с удаленным репозиторием, сохранены ли изменения, закомичены ли они. Лишний раз 
`git status` набери, не помешает. И конечно, не забывай про google всемогущий.


# GIT-IGNORE
## В процессе работы над любым проектом в директории с кодом создаются файлы, которые не являются частью исходного кода. Все эти файлы можно условно разделить на несколько групп:
### Инструментарий:
` Служебные файлы, добавляемые операционной системой — например, .DS_Store в MacOS`
` Конфигурационные и временные файлы редакторов — например, .idea или .vscode`
### Временные файлы:
 Логи — в них содержится полезная информация для отладки, которая собирается во время запуска и работы приложения
 Кеши — файлы, которые нужны для ускорения разных процессов
### Артефакты:
` Результаты сборки проекта — например, после компиляции или сборки фронтенда`
` Зависимости, которые устанавливаются во время разработки — например, node_modules или vendor`
` Результаты выполнения тестов — например, информация о покрытии кода тестами`
## Все это в обычной ситуации не должно попадать в репозиторий. В этом уроке вы узнаете, как проигнорировать эти файлы.
##Как правило, эти файлы не несут никакой пользы с точки зрения исходного кода. Они создаются:
`Автоматически (кеши, логи)`
`По запросу (например, скачиваются зависимости или собирается проект)`
## Игнорируем файл в любой директории проекта
`access.log`
## Игнорируем директорию в любой директории проекта
`node_modules/`
## Игнорируем каталог в корне рабочей директории
`/coverage/`
### Игнорируем все файлы с расширением `sqlite3` в директории db
### При этом не игнорируются такие же файлы внутри любого вложенного каталога в db
### Например
`/db/something/lala.sqlite3`
`/db/*.sqlite3`
### Игнорировать все .txt файлы в каталоге doc/ на всех уровнях вложенности
`doc/**/*.txt`
`touch .gitignore`
## Добавляем в файл правила игнорирования по примеру выше
`git add .gitignore`
`git commit -m 'update gitignore'`
### Как только .gitignore создан и в него добавлен какой-то файл или директория, игнорирование заработает автоматически. Все новые файлы, попадающие под игнорирование, не отобразятся в выводе команды
`git status`



# Ветвление в Git - Основы ветвления и слияния

### Вы выбрали задачу #53 из какая-там-у-вас-система-отслеживания-задач. Чтобы создать ветку и сразу переключиться на неё, можно выполнить команду git checkout с параметром -b:

`git checkout -b iss53`
Switched to a new branch "iss53"

Это то же самое, что и:

`git branch iss53`
`git checkout iss53`

Вы работаете над сайтом и делаете коммиты. Это приводит к тому, что ветка iss53 движется вперед, так как вы переключились на неё ранее (HEAD указывает на неё).

`vim index.html`
`git commit -a -m 'Create new footer [issue 53]'`


И тут вы получаете сообщение об обнаружении на сайте уязвимости, и эту уязвимость устранить нужно немедленно. Благодаря Git вам не придётся ни пытаться реализовать исправление вместе с изменениями, которые вы сделали в ходе разработки iss53, ни прилагать усилия для отката этих изменений и возвращения к исходному состоянию перед началом разработки исправления. Все, что вам нужно — переключиться на ветку master.

Имейте в виду, что если рабочий каталог или индекс содержат незафиксированные изменения, конфликтующие с веткой, на которую вы хотите переключиться, то Git не позволит переключить ветки. Лучше всего переключаться из чистого рабочего состояния проекта: все изменённые файлы добавить в индекс и сделать коммит. Есть способы обойти это (припрятать изменения (stash) или добавить их в последний коммит (amend)), но об этом мы поговорим позже в разделе Припрятывание и очистка главы 7. Теперь предположим, что вы зафиксировали все свои изменения и можете переключиться на ветку master:

`git checkout master`
> Switched to branch 'master'

С этого момента ваш рабочий каталог имеет точно такой же вид, какой был перед началом работы над задачей #53, и вы можете сосредоточиться на работе над исправлением. Важно запомнить: когда вы переключаете ветки, Git возвращает состояние рабочего каталога к тому виду, какой он имел в момент последнего коммита в переключаемую ветку. Он добавляет, удаляет и изменяет файлы автоматически, чтобы состояние рабочего каталога соответствовало тому, когда был сделан последний коммит.

Теперь вы можете перейти к написанию исправления. Давайте создадим новую ветку, в которой реализуем исправление.

`git checkout -b hotfix`
> Switched to a new branch 'hotfix'
`vim index.html`
`git commit -a -m 'Fix broken email address'`
> [hotfix 1fb7853] Fix broken email address
> 1 file changed, 2 insertions(+)


Вы можете прогнать тесты, чтобы убедиться, что ваше уязвимость в самом деле исправлена. И если это так — выполнить слияние ветки hotfix с веткой master для включения изменений в продукт. Это делается командой git merge:

`git checkout master`
`git merge hotfix`
> Updating f42c576..3a0874c
> Fast-forward
> index.html | 2 ++
> 1 file changed, 2 insertions(+)

Заметили фразу «fast-forward» в этом слиянии? Git просто переместил указатель ветки вперед, потому что коммит C4, на который указывает слитая ветка hotfix, был прямым потомком коммита C2, на котором вы находились до этого. Другими словами, если коммит сливается с тем, до которого можно добраться, двигаясь по истории вперёд, Git упрощает слияние, просто перенося указатель ветки вперед, потому что в этом случае нет никаких разнонаправленных изменений, которые нужно было бы свести воедино. Это называется «fast-forward».
Теперь ваши изменения включены в коммит, на который указывает ветка master, и исправление можно внедрять.

После внедрения вашего архиважного исправления вы готовы вернуться к работе над тем, что были вынуждены отложить. Но сначала нужно удалить ветку hotfix, потому что она больше не нужна — ветка master указывает на то же самое место. Для удаления ветки выполните команду `git branch` с параметром -d:

`git branch -d hotfix`
> Deleted branch hotfix (3a0874c).

Теперь вы можете переключиться обратно на ветку iss53 и продолжить работу над задачей #53:

`git checkout iss53`
> Switched to branch "iss53"\
`vim index.html`
`git commit -a -m 'Finish the new footer [issue 53]'`
> [iss53 ad82d7a] Finish the new footer [issue 53]
> 1 file changed, 1 insertion(+)
Стоит обратить внимание на то, что все изменения из ветки hotfix не включены в вашу ветку iss53. Если их нужно включить, вы можете влить ветку master в вашу ветку iss53 командой git merge master, а можете отложить слияние этих изменений до завершения работы, и затем влить ветку iss53 в master.


Предположим, вы решили, что работа по проблеме #53 закончена и её можно влить в ветку master. Для этого нужно выполнить слияние ветки iss53 точно так же, как вы делали это с веткой hotfix ранее. Все, что нужно сделать — переключиться на ветку, в которую вы хотите включить изменения, и выполнить команду git merge:

`git checkout master`
> Switched to branch 'master'
`git merge iss53`
> Merge made by the 'recursive' strategy.
> index.html |    1 +
> 1 file changed, 1 insertion(+)

Результат этой операции отличается от результата слияния ветки hotfix. В данном случае процесс разработки ответвился в более ранней точке. Так как коммит, на котором мы находимся, не является прямым родителем ветки, с которой мы выполняем слияние, Git придётся немного потрудиться. В этом случае Git выполняет простое трёхстороннее слияние, используя последние коммиты объединяемых веток и общего для них родительского коммита.

Теперь, когда изменения слиты, ветка iss53 больше не нужна. Вы можете закрыть задачу в системе отслеживания ошибок и удалить ветку:
`git branch -d iss53`

## Основные конфликты слияния

Иногда процесс не проходит гладко. Если вы изменили одну и ту же часть одного и того же файла по-разному в двух объединяемых ветках, Git не сможет их чисто объединить. Если ваше исправление ошибки #53 потребовало изменить ту же часть файла что и hotfix, вы получите примерно такое сообщение о конфликте слияния:

`git merge iss53`
> Auto-merging index.html
> CONFLICT (content): Merge conflict in index.html
> Automatic merge failed; fix conflicts and then commit the result.

Git не создал коммит слияния автоматически. Он остановил процесс до тех пор, пока вы не разрешите конфликт. Чтобы в любой момент после появления конфликта увидеть, какие файлы не объединены, вы можете 
запустить `git status`.

Если вы хотите использовать графический инструмент для разрешения конфликтов, можно запустить `git mergetool`, который проведет вас по всем конфликтам:

Если вы хотите использовать инструмент слияния не по умолчанию (в данном случае Git выбрал `opendiff`, поскольку команда запускалась на Mac), список всех поддерживаемых инструментов представлен вверху после фразы «one of the following tools». Просто введите название инструмента, который хотите использовать.

После выхода из инструмента слияния Git спросит об успешности процесса. Если вы ответите скрипту утвердительно, то он добавит файл в индекс, чтобы отметить его как разрешённый. Теперь можно снова запустить `git status`, чтобы убедиться в отсутствии конфликтов.

Если это вас устраивает и вы убедились, что все файлы, где были конфликты, добавлены в индекс — выполните команду `git commit` для создания коммита слияния.
